This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-09T02:05:43.656Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
ai-agents-backend/.env.example
ai-agents-backend/.gitignore
ai-agents-backend/configs/connectDatabase.js
ai-agents-backend/index.js
ai-agents-backend/middlewares/authMiddleware.js
ai-agents-backend/models/agents.js
ai-agents-backend/models/user.js
ai-agents-backend/package.json
ai-agents-extension/content.js
ai-agents-extension/manifest.json
ai-agents-extension/README.md
ai-agents-extension/styles.css

================================================================
Repository Files
================================================================

================
File: ai-agents-backend/.env.example
================
PORT =
MONGODB_URL =

================
File: ai-agents-backend/.gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# env
.env

================
File: ai-agents-backend/configs/connectDatabase.js
================
const mongoose = require("mongoose");

const connectDatabase = () => {
    mongoose
        .connect(process.env.MONGODB_URL)
        .then(() => console.log("MongoDB connected!"));
};

module.exports = connectDatabase;

================
File: ai-agents-backend/index.js
================
require("dotenv").config();
const express = require("express");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const app = express();
const cors = require("cors");
const authMiddleware = require("./middlewares/authMiddleware");
const connectDatabase = require("./configs/connectDatabase");
const User = require("./models/user");
const Agent = require("./models/agents");

// Enable CORS with specific origin
app.use(
    cors({
        origin: "https://chatgpt.com", // Allow requests from your extension's domain
        methods: ["GET", "POST", "PUT", "DELETE"],
        allowedHeaders: ["Content-Type", "Authorization"],
    })
);

connectDatabase();

app.use(express.json());

const SECRET_KEY = "SECRET_KEY";

// User registration
app.post("/register", async (req, res) => {
    const { username, password } = req.body;
    const hashedPassword = await bcrypt.hash(password, 10);

    try {
        const newUser = await User.create({
            username,
            password: hashedPassword,
        });
        res.json(newUser);
    } catch (err) {
        res.status(500).json(err);
    }
});

// User login
app.post("/login", async (req, res) => {
    const { username, password } = req.body;

    try {
        const user = await User.findOne({ username });
        if (!user) return res.status(404).json({ error: "User not found" });

        const validPassword = await bcrypt.compare(password, user.password);
        if (!validPassword)
            return res.status(401).json({ error: "Invalid password" });

        const token = jwt.sign({ id: user._id }, SECRET_KEY, {
            expiresIn: "1h",
        });
        res.json({ token });
    } catch (err) {
        res.status(500).json(err);
    }
});

// Get all agents
app.get("/agents", async (req, res) => {
    const agents = await Agent.find();
    res.json(agents);
});

// Add an agent
app.post("/agents", authMiddleware, async (req, res) => {
    const { name, description, prompt, formFields } = req.body;

    try {
        const newAgent = await Agent.create({
            name,
            description,
            prompt,
            formFields,
            createdBy: req.user.id,
        });
        res.json(newAgent);
    } catch (err) {
        res.status(500).json(err);
    }
});

// Update an agent
app.put("/agents/:id", authMiddleware, async (req, res) => {
    const { id } = req.params;

    try {
        const agent = await Agent.findOne({ _id: id, createdBy: req.user.id });
        if (!agent) return res.status(403).json({ error: "Unauthorized" });

        const updatedAgent = await Agent.findByIdAndUpdate(id, req.body, {
            new: true,
        });
        res.json(updatedAgent);
    } catch (err) {
        res.status(500).json(err);
    }
});

// Delete an agent
app.delete("/agents/:id", authMiddleware, async (req, res) => {
    const { id } = req.params;

    try {
        const agent = await Agent.findOne({ _id: id, createdBy: req.user.id });
        if (!agent) return res.status(403).json({ error: "Unauthorized" });

        await Agent.findByIdAndDelete(id);
        res.json({ message: "Agent deleted" });
    } catch (err) {
        res.status(500).json(err);
    }
});

// Clone an agent
app.post("/agents/:id/clone", authMiddleware, async (req, res) => {
    const { id } = req.params;

    try {
        const agent = await Agent.findById(id);
        if (!agent) return res.status(404).json({ error: "Agent not found" });

        const clonedAgent = await Agent.create({
            ...agent.toObject(),
            _id: undefined,
            createdBy: req.user.id,
        });
        res.json(clonedAgent);
    } catch (err) {
        res.status(500).json(err);
    }
});

// Start server
app.listen(3000, () => console.log("Server running on port 3000"));

================
File: ai-agents-backend/middlewares/authMiddleware.js
================
const jwt = require("jsonwebtoken");

const authMiddleware = (req, res, next) => {
    const token = req.headers["authorization"];
    if (!token) return res.status(401).json({ error: "Access Denied" });

    try {
        const verified = jwt.verify(token, "SECRET_KEY");
        req.user = verified;
        next();
    } catch (err) {
        res.status(400).json({ error: "Invalid Token" });
    }
};

module.exports = authMiddleware;

================
File: ai-agents-backend/models/agents.js
================
const mongoose = require("mongoose");

const agentSchema = new mongoose.Schema(
    {
        name: { type: String, required: true },
        description: { type: String, required: true },
        prompt: { type: String, required: true },
        formFields: { type: Array, default: [] },
        createdBy: {
            type: mongoose.Schema.Types.ObjectId,
            ref: "User",
            required: true,
        },
    },
    { timestamps: true }
);

const Agent = mongoose.model("Agent", agentSchema);

module.exports = Agent;

================
File: ai-agents-backend/models/user.js
================
const mongoose = require("mongoose");

const userSchema = new mongoose.Schema({
    username: { type: String, unique: true, required: true },
    password: { type: String, required: true },
});

const User = mongoose.model("User", userSchema);

module.exports = User;

================
File: ai-agents-backend/package.json
================
{
    "name": "ai-agents-backend",
    "version": "1.0.0",
    "main": "index.js",
    "scripts": {
        "start:dev": "nodemon index.js",
        "start": "node index.js"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "description": "",
    "dependencies": {
        "bcrypt": "^5.1.1",
        "cors": "^2.8.5",
        "dotenv": "^16.4.7",
        "express": "^4.21.2",
        "jsonwebtoken": "^9.0.2",
        "mongoose": "^8.8.4"
    },
    "devDependencies": {
        "nodemon": "^3.1.7"
    }
}

================
File: ai-agents-extension/content.js
================
// content.js
const agents = [
    {
        name: "Content Creator",
        description: "Create blog content optimized for SEO.",
        prompt: "Create a blog optimized for SEO:",
        formFields: [
            {
                label: "Topic of the Blog",
                type: "text",
                placeholder: "Enter the blog topic",
                default: "",
            },
            {
                label: "Number of Blogs",
                type: "number",
                placeholder: "Enter the number of blogs",
                default: "1",
            },
        ],
    },
    {
        name: "Summarizer",
        description: "Summarizes text for clarity.",
        prompt: "Summarize the following content:",
        formFields: [],
    },
    {
        name: "English Translator",
        description: "Translates text into English.",
        prompt: `
        You are an expert English-to-Vietnamese translator specializing in light novels. Your task is to translate the story *Too Many Losing Heroines* into Vietnamese while preserving the conversational and natural tone typical of light novels.  

        Maintain the distinct personalities and tones of all characters in the dialogue, ensuring their unique speech patterns and mannerisms come across naturally in Vietnamese. Additionally, provide concise footnotes or in-line explanations for cultural references, idiomatic expressions, or phrases that might not directly translate to Vietnamese. These explanations should clarify the meaning while keeping the reading experience immersive.  

        When translating:  
        - Use modern and relatable Vietnamese vocabulary that fits the tone of a light novel.  
        - Avoid overly formal or outdated language unless explicitly required by the context.  
        - Stay true to the original text while ensuring it feels natural in Vietnamese.  
        - Highlight any parts where clarification was necessary or significant adaptations were made for the target audience.  

        Example communication style:  
        In previous projects, I prioritize maintaining the natural flow of conversation, reflecting how native speakers communicate. I also prefer providing clear and accessible explanations for any cultural nuances or idioms, helping the reader connect better with the text.

        ---

        **Critique:**  
        This draft effectively captures your main goals but could benefit from a specific example to demonstrate how idiomatic expressions should be explained or how character tones should be adapted. Additionally, clarifying the level of detail expected in explanations (e.g., short one-liners or detailed notes) would improve precision.

        ---

        **Questions:**  
        1. Should the explanations for cultural references be included as in-line comments, footnotes, or endnotes?  
        2. Are there specific types of idiomatic expressions or cultural references you would like handled differently (e.g., localized vs. explained literally)?  
        3. Would you like a brief summary of changes or adaptations after the translation of each chapter?  
        `,
        formFields: [],
    },
    {
        name: "Prompt Generator",
        description: "Generate prompts for ChatGPT.",
        prompt: `
            I want you to become my Expert Prompt Creator. Your goal is to help me craft the best possible prompt for my needs. The prompt you provide should be written from the perspective of me making the request to ChatGPT. Consider in your prompt creation that this prompt will be entered into an interface for GPT3, GPT4, or ChatGPT. The prompt will include instructions to write the output using my communication style. The process is as follows:

1. You will generate the following sections:

"
**Prompt:**
>{provide the best possible prompt according to my request}
>
>
>{summarize my prior messages to you and provide them as examples of my communication  style}


**Critique:**
{provide a concise paragraph on how to improve the prompt. Be very critical in your response. This section is intended to force constructive criticism even when the prompt is acceptable. Any assumptions and or issues should be included}

**Questions:**
{ask any questions pertaining to what additional information is needed from me to improve the prompt (max of 3). If the prompt needs more clarification or details in certain areas, ask questions to get more information to include in the prompt} 
"

2. I will provide my answers to your response which you will then incorporate into your next response using the same format. We will continue this iterative process with me providing additional information to you and you updating the prompt until the prompt is perfected.

Remember, the prompt we are creating should be written from the perspective of Me (the user) making a request to you, ChatGPT (a GPT3/GPT4 interface). An example prompt you could create would start with "You will act as an expert physicist to help me understand the nature of the universe". 

Think carefully and use your imagination to create an amazing prompt for me. 

Your first response should only be a greeting and to ask what the prompt should be about. 
        `,
        formFields: [],
    },
];

// Create sidebar
const sidebar = document.createElement("div");
sidebar.className = "sidebar";
document.body.appendChild(sidebar);

// Render agents (example)
agents.forEach((agent) => {
    const agentItem = document.createElement("div");
    agentItem.className = "agent-item";
    agentItem.innerHTML = `
      <div class="agent-name">${agent.name}</div>
      <div class="agent-description">${agent.description}</div>
    `;
    agentItem.addEventListener("click", () => handleAgentClick(agent));
    sidebar.appendChild(agentItem);
});

const handleAgentClick = (agent) => {
    // Check if the form exists already
    const existingCustomForm = document.querySelector("#custom-agent-form");
    console.log("Existing form: ", existingCustomForm); // Debug log
    if (existingCustomForm) existingCustomForm.remove();

    // Get the chat input container and check if it exists
    const chatContainer =
        document.querySelector("div.ProseMirror")?.parentElement;
    console.log("Chat container found: ", chatContainer); // Debug log
    if (!chatContainer) return;

    // If the agent has no form fields, render the basic prompt directly
    if (!agent.formFields || agent.formFields.length === 0) {
        const chatInput = document.querySelector("div.ProseMirror");
        if (chatInput) {
            // Replace HTML content with formatted text
            const formattedPrompt = agent.prompt
                .replace(/\n/g, "<br>") // Convert newlines to HTML line breaks
                .replace(/ {2}/g, "&nbsp;&nbsp;"); // Preserve spaces for indentation

            chatInput.innerHTML = formattedPrompt;

            // Simulate input event to ensure the submit button appears
            chatInput.dispatchEvent(new Event("input", { bubbles: true }));
        }
        return;
    }

    // Create a form container if form fields exist
    const formContainer = document.createElement("div");
    formContainer.id = "custom-agent-form";
    formContainer.className = "space-y-4";

    // Add fields dynamically from the agent's formFields
    agent.formFields.forEach((field) => {
        const fieldWrapper = document.createElement("div");

        const label = document.createElement("label");
        label.textContent = field.label;
        label.className = "block text-sm font-medium text-gray-700";

        const input = document.createElement("input");
        input.type = field.type;
        input.placeholder = field.placeholder;
        input.defaultValue = field.default || "";
        input.className =
            "block w-full px-3 py-2 border rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm";

        // Add an event listener to update the prompt whenever the input changes
        input.addEventListener("input", updateCombinedPrompt);

        fieldWrapper.appendChild(label);
        fieldWrapper.appendChild(input);
        formContainer.appendChild(fieldWrapper);
    });

    // Insert the new form above the default input field
    chatContainer.insertBefore(formContainer, chatContainer.firstChild);

    // Function to combine inputs and update the textarea
    function updateCombinedPrompt() {
        const userInputs = Array.from(formContainer.querySelectorAll("input"))
            .map((input) => `${input.placeholder}: ${input.value}`)
            .join("\n");

        // Combine the agent prompt with the user inputs
        const combinedPrompt = `${agent.prompt}\n${userInputs}`;

        // Get the chat input area (ProseMirror div) and set the combined prompt
        const chatInput = document.querySelector("div.ProseMirror");
        if (chatInput) {
            // Replace with formatted prompt
            const formattedPrompt = combinedPrompt
                .replace(/\n/g, "<br>")
                .replace(/ {2}/g, "&nbsp;&nbsp;");

            chatInput.innerHTML = formattedPrompt;

            // Simulate input event to ensure the submit button appears
            chatInput.dispatchEvent(new Event("input", { bubbles: true }));
        }
    }
};

================
File: ai-agents-extension/manifest.json
================
{
    "manifest_version": 3,
    "name": "ChatGPT AI Agents",
    "description": "Sidebar extension for AI agents in ChatGPT.",
    "version": "1.0",
    "permissions": ["scripting", "activeTab"],
    "host_permissions": ["https://chat.openai.com/*"],
    "content_scripts": [
        {
            "matches": ["https://chat.openai.com/*", "https://chatgpt.com/*"],
            "js": ["content.js"],
            "css": ["styles.css"]
        }
    ]
}

================
File: ai-agents-extension/README.md
================
# ChatGPT AI Agents Extension

## Overview

The ChatGPT AI Agents extension is a browser extension that enhances the ChatGPT experience by providing a sidebar with various AI agents. Each agent can assist users in generating content, summarizing text, and more, with customizable input fields.

## Features

-   Sidebar interface for easy access to AI agents.
-   Dynamic form fields for user input based on selected agent.
-   Integration with ChatGPT's input area for seamless interaction.

## Installation

1. Clone the repository:

    ```bash
    git clone https://github.com/yourusername/chatgpt-ai-agents.git
    cd chatgpt-ai-agents
    ```

2. Load the extension in your browser:

    - For Chrome:
        1. Open Chrome and go to `chrome://extensions/`.
        2. Enable "Developer mode" in the top right corner.
        3. Click "Load unpacked" and select the directory where the extension files are located.

3. Ensure you have the necessary permissions set in the `manifest.json` file.

## Usage

1. Navigate to the ChatGPT website.
2. Click on the extension icon to open the sidebar.
3. Select an AI agent from the list to display its description and input fields.
4. Fill in the required fields and focus on the ChatGPT input area to combine the agent's prompt with your inputs.

## Key Components

### `manifest.json`

Defines the extension's metadata, permissions, and content scripts.

### `content.js`

Handles the creation of the sidebar, rendering of agents, and dynamic form generation based on user selection.

### `agents.json`

Stores the configuration for each AI agent, including their names, descriptions, prompts, and form fields.

### `styles.css`

Contains the styles for the sidebar and agent items, ensuring a user-friendly interface.

## Example Agent Configuration

## Contributing

Contributions are welcome! Please submit a pull request or open an issue for any enhancements or bug fixes.

## License

This project is licensed under the MIT License. See the LICENSE file for details.

================
File: ai-agents-extension/styles.css
================
.sidebar {
    position: fixed;
    top: 0;
    right: 0;
    height: 100%;
    width: 300px;
    background: #f3f4f6;
    border-left: 1px solid #e5e7eb;
    padding: 1rem;
    box-shadow: -3px 0 5px rgba(0, 0, 0, 0.1);
    z-index: 1000;
}

.agent-item {
    display: flex;
    flex-direction: column;
    margin-bottom: 1rem;
    cursor: pointer;
    padding: 0.75rem;
    border-radius: 0.375rem;
    transition: background 0.3s, color 0.3s;
}

.agent-item:hover {
    background: #e5e7eb;
    color: #1f2937;
}

.agent-name {
    font-weight: bold;
    margin-bottom: 0.5rem;
}

.agent-description {
    color: #6b7280;
}

#custom-agent-form {
    margin-bottom: 1rem;
}

#custom-agent-form input {
    padding: 0.5rem;
    border: 1px solid #d1d5db;
    border-radius: 0.375rem;
    width: 100%;
}

#custom-agent-form label {
    margin-bottom: 0.25rem;
    font-weight: 500;
    display: block;
    color: #374151;
}
